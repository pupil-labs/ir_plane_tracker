{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pupil Labs IR Plane Tracker","text":"<p>[!IMPORTANT] This package is a work in progress. Use at your own risk! The API may change without warning, the computational performance is not optimized, and the tracking performance may lack in some cases.</p> <p>This repository implements a marker-based plane tracking algorithm that is in particular suited for screen tracking.</p> <p>Ideally, the camera is an IR camera with the markers made from a retroreflective material, but a regular RGB camera with black-and-white markers also works to some extent.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#installation","title":"Installation","text":"<p>To install the package and its dependencies, run the following commands:</p> <pre><code>git clone git@github.com:pupil-labs/ir_plane_tracker.git\ncd ir_plane_tracker/\n\nuv sync --group examples\n# alternatively via pip:\n# pip install .[examples]\n</code></pre>"},{"location":"#example-applications","title":"Example Applications","text":"<p>The project contains an example application that demonstrates gaze mapping onto a screen. For convenience, the markers are displayed by the app on the screen, which allows to determine their position on the screen automatically. Thus, running this example requires no setup.</p> <p>Run the example using the following command, providing the IP of a Neon device on your network as an argument:</p> <pre><code>cd examples/\n\npython gaze_mapping_app_main.py --params_path resources/params.json --neon_ip &lt;NEON_IP_ADDRESS&gt;\n</code></pre> <p>Note, you can find the IP of your Neon device from the Neon Companion app when you open the network panel by clicking the icon in the top right corner of the home screen.</p>"},{"location":"#marker-display","title":"Marker Display","text":"<p>A minimal example that simply displays the markers on the screen is available in the <code>examples/feature_display_app.py</code> file. You can run it using the following command:</p> <pre><code>cd examples/\npython feature_display_app.py --params_path resources/params.json\n</code></pre>"},{"location":"#marker-placement","title":"Marker Placement","text":"<p>For the algorithm to work, markers need to be placed around the boundary of the rectangular plane of interest (one marker per boundary). The markers need to be co-planar with the plane and parallel to the boundaries. To optimize visibility and occlusion resistence, the markers are ideally placed close to the center of their respective boundary.</p> <p>The markers may be placed inside or outside of the plane of interest. If the plane is a screen, the markers may be displayed on the screen out of convenience. In many cases, it is preferable to place the markers outside of the plane of interest, to avoid occlusion of the plane's content by the markers.</p> <p>The exact position of the markers has to be specified as part of the input parameters.</p>"},{"location":"#using-printed-markers","title":"Using Printed Markers","text":"<p>You can print this PDF on a DIN A4 sheet of paper to get markers in the right size for typical screen tracking setups. If the viewing distance is larger than ~1 meter, you will have to use larger markers (see TODO).</p> <p>You have to measure the position of each marker in realtion to the plane and specify it as an input parameter (in the <code>params.json</code> file). The needed parameters are <code>top_pos</code>, <code>bot_pos</code>, <code>left_pos</code>, and <code>right_pos</code> which describe the position of the marker on the respective boundary.</p> <p>The orientation of the marker also matters and should follow what is visible in the example below.</p> <p>A markers position is defined by the position of the outter circular feature. The origin of the plane coordinate system is the top left corner.</p> <p></p> <p>If your target plane is a screen, you may use the the app available in <code>examples/ruler_app_main.py</code> to display rulers on the screen to help with measuring the marker positions.</p> <p>In addition to the marker positions, you also need to specify the size of the plane in the <code>params.json</code> file using the <code>plane_width</code> and <code>plane_height</code> parameters.</p>"},{"location":"#displaying-markers-on-screen","title":"Displaying Markers on Screen","text":"<p>If your target plane is a screen, you may also display the markers on the screen itself. This has the downside of occluding some of the screen area, but is convenient as it allows to determine the marker positions automatically.</p> <p>The repository contains an exemplary PySide6 widget that displays the markers in the correct size and contains functionality to retrieve their positions in screen coordinates as well as the size of the screen.</p> <p>It's usage is demonstrated in the <code>examples/gaze_mapping_app_main.py</code> example application and a more minimal example in the <code>examples/feature_display_app.py</code> file.</p> <p>Alternatively, you can also display the markers and determine the input parameters manually. An image of the marker is available here.</p> <p></p>"},{"location":"#optimizing-performance","title":"Optimizing Performance","text":"<p>Lighting conditions and camera exposure settings play a role in optimizing tracking performance. Ideally, the environment is well illuminated, such that the scene camera captures well exposed images.</p> <p>If the camera is set to auto-exposure, setting it to \"Highlights\" typically yields better results.</p> <p>If the environment is not bright enough, the auto-exposure will use exposure times that can lead to motion blur, which negatively impacts tracking performance. If this is an issue, it is advisable to either improve the lighting conditions or switch to manual exposure settings and set a fixed exposure time that avoids motion blur. A manual exposure value &lt;120 typically reduced motion blur sufficiently to deal with typical head movements.</p> <p>a</p>"},{"location":"license/","title":"License","text":"<pre><code>Copyright (c) 2025, Pupil Labs GmbH\n\nAll rights reserved.\n</code></pre>"},{"location":"modules/","title":"API reference","text":""},{"location":"modules/#pupil_labs.ir_plane_tracker","title":"ir_plane_tracker","text":"<p>pupil_labs.ir_plane_tracker package.</p> <p>A tool for tracking planes marked with markers.</p> <p>Modules:</p> <ul> <li> <code>tracker</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>PlaneLocalization</code>           \u2013            <p>Result of plane localization.</p> </li> <li> <code>Tracker</code>           \u2013            <p>A Tracker for tracking planes marked with markers.</p> </li> <li> <code>TrackerParams</code>           \u2013            <p>Parameters for the IR plane tracker.</p> </li> </ul>"},{"location":"modules/#pupil_labs.ir_plane_tracker.PlaneLocalization","title":"PlaneLocalization  <code>dataclass</code>","text":"<pre><code>PlaneLocalization(corners: NDArray[float64], img2plane: NDArray[float64], plane2img: NDArray[float64], reprojection_error: float)\n</code></pre> <p>Result of plane localization.</p> <p>Attributes:</p> <ul> <li> <code>corners</code>               (<code>NDArray[float64]</code>)           \u2013            <p>Corners of the plane in image coordinates.</p> </li> <li> <code>img2plane</code>               (<code>NDArray[float64]</code>)           \u2013            <p>Transformation matrix from image to plane coordinates.</p> </li> <li> <code>plane2img</code>               (<code>NDArray[float64]</code>)           \u2013            <p>Transformation matrix from plane to image coordinates.</p> </li> <li> <code>reprojection_error</code>               (<code>float</code>)           \u2013            <p>Reprojection error of the localization in pixels.</p> </li> </ul>"},{"location":"modules/#pupil_labs.ir_plane_tracker.PlaneLocalization.corners","title":"corners  <code>instance-attribute</code>","text":"<pre><code>corners: NDArray[float64]\n</code></pre> <p>Corners of the plane in image coordinates.</p>"},{"location":"modules/#pupil_labs.ir_plane_tracker.PlaneLocalization.img2plane","title":"img2plane  <code>instance-attribute</code>","text":"<pre><code>img2plane: NDArray[float64]\n</code></pre> <p>Transformation matrix from image to plane coordinates.</p>"},{"location":"modules/#pupil_labs.ir_plane_tracker.PlaneLocalization.plane2img","title":"plane2img  <code>instance-attribute</code>","text":"<pre><code>plane2img: NDArray[float64]\n</code></pre> <p>Transformation matrix from plane to image coordinates.</p>"},{"location":"modules/#pupil_labs.ir_plane_tracker.PlaneLocalization.reprojection_error","title":"reprojection_error  <code>instance-attribute</code>","text":"<pre><code>reprojection_error: float\n</code></pre> <p>Reprojection error of the localization in pixels.</p>"},{"location":"modules/#pupil_labs.ir_plane_tracker.Tracker","title":"Tracker","text":"<pre><code>Tracker(camera_matrix: NDArray[float64], dist_coeffs: NDArray[float64], params: TrackerParams | None = None)\n</code></pre> <p>A Tracker for tracking planes marked with markers.</p> <p>Parameters:</p> <ul> <li> <code>camera_matrix</code>               (<code>NDArray[float64]</code>)           \u2013            <p>Camera intrinsic matrix.</p> </li> <li> <code>dist_coeffs</code>               (<code>NDArray[float64]</code>)           \u2013            <p>Camera distortion coefficients.</p> </li> <li> <code>params</code>               (<code>TrackerParams | None</code>, default:                   <code>None</code> )           \u2013            <p>Tracker parameters. If None, default parameters are used.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              <p>Tracks the plane in the given image.</p> </li> </ul> Source code in <code>src/pupil_labs/ir_plane_tracker/tracker.py</code> <pre><code>def __init__(\n    self,\n    camera_matrix: npt.NDArray[np.float64],\n    dist_coeffs: npt.NDArray[np.float64],\n    params: TrackerParams | None = None,\n):\n    \"\"\"Creates a Tracker instance for tracking planes marked with markers.\n\n    Args:\n        camera_matrix: Camera intrinsic matrix.\n        dist_coeffs: Camera distortion coefficients.\n        params: Tracker parameters. If None, default parameters are used.\n\n    \"\"\"\n    self.camera_matrix = camera_matrix\n    self.dist_coeffs = dist_coeffs\n    if params is None:\n        self.params = TrackerParams()\n    else:\n        self.params = params\n\n    self.debug = DebugData(self.params)\n</code></pre>"},{"location":"modules/#pupil_labs.ir_plane_tracker.Tracker.__call__","title":"__call__","text":"<pre><code>__call__(image: NDArray[uint8]) -&gt; PlaneLocalization | None\n</code></pre> <p>Tracks the plane in the given image.</p> <p>Parameters:</p> <ul> <li> <code>image</code>               (<code>NDArray[uint8]</code>)           \u2013            <p>Input image.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PlaneLocalization | None</code>           \u2013            <p>PlaneLocalization if the plane is found, None otherwise.</p> </li> </ul> Source code in <code>src/pupil_labs/ir_plane_tracker/tracker.py</code> <pre><code>def __call__(self, image: npt.NDArray[np.uint8]) -&gt; PlaneLocalization | None:\n    \"\"\"Tracks the plane in the given image.\n\n    Args:\n        image: Input image.\n\n    Returns:\n        PlaneLocalization if the plane is found, None otherwise.\n\n    \"\"\"\n    self.debug = DebugData(self.params)\n    self.debug.img_raw = image.copy()\n    # image = cv2.undistort(image, self.camera_matrix, self.dist_coeffs)\n\n    if self.params.debug:\n        self.vis = image.copy()\n\n    image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n    self.debug.img_gray = image.copy()\n\n    line_contours, ellipse_contours = self.get_contours(image)\n    if len(line_contours) &lt; self.params.min_line_contour_count:\n        return None\n    if len(ellipse_contours) &lt; self.params.min_ellipse_contour_count:\n        return None\n\n    fragments = self.fit_line_fragments(line_contours)\n    if len(fragments) &lt; self.params.min_line_fragments_count:\n        return None\n\n    ellipses = self.fit_ellipses_to_contours(ellipse_contours, image.shape[:2])\n    if len(ellipses) &lt; self.params.min_ellipse_count:\n        return None\n\n    feature_lines = self.find_feature_lines(fragments, ellipses)\n    if len(feature_lines) &lt; self.params.min_feature_line_count:\n        return None\n\n    combinations = self.get_possible_combinations(feature_lines)\n\n    rvec, tvec = self.fit_camera_pose(combinations)\n\n    if rvec is None or tvec is None:\n        return None\n\n    screen_corners = self.calculate_localization(rvec, tvec)\n\n    return screen_corners\n</code></pre>"},{"location":"modules/#pupil_labs.ir_plane_tracker.TrackerParams","title":"TrackerParams  <code>dataclass</code>","text":"<pre><code>TrackerParams(plane_width: float = nan, plane_height: float = nan, top_pos: tuple[float, float] = (nan, nan), bottom_pos: tuple[float, float] = (nan, nan), right_pos: tuple[float, float] = (nan, nan), left_pos: tuple[float, float] = (nan, nan), feature_point_positions_mm: NDArray[float64] = lambda: array([0.0, 6.0, 8.0, 10.0])(), padding_mm: float = 5.0, circle_diameter_mm: float = 6.0, line_thickness_mm: float = 3.0, img_size_factor: float = 1.0, thresh_c: int = 45, thresh_half_kernel_size: int = 20, min_contour_area_line: int = 70, max_contour_area_line: int = 360, min_contour_area_ellipse: int = 12, max_contour_area_ellipse: int = 70, min_line_contour_count: int = 3, min_ellipse_contour_count: int = 6, min_contour_support: int = 6, fragments_min_length: float = 30.0, fragments_max_length: float = 70.0, fragments_max_projection_error: float = 5.0, min_line_fragments_count: int = 3, min_ellipse_size: int = 4, max_ellipse_aspect_ratio: float = 2.0, min_ellipse_count: int = 8, max_cr_error: float = 0.12, max_feature_line_length: float = 150.0, min_feature_line_count: int = 3, feature_line_max_projection_error: float = 2.0, optimization_error_threshold: float = 15.0, debug: bool = False)\n</code></pre> <p>Parameters for the IR plane tracker.</p> <p>Attributes:</p> <ul> <li> <code>bottom_pos</code>               (<code>tuple[float, float]</code>)           \u2013            <p>Position of the bottom marker in mm.</p> </li> <li> <code>left_pos</code>               (<code>tuple[float, float]</code>)           \u2013            <p>Position of the left marker in mm.</p> </li> <li> <code>plane_height</code>               (<code>float</code>)           \u2013            <p>Height of the tracked plane in mm.</p> </li> <li> <code>plane_width</code>               (<code>float</code>)           \u2013            <p>Width of the tracked plane in mm.</p> </li> <li> <code>right_pos</code>               (<code>tuple[float, float]</code>)           \u2013            <p>Position of the right marker in mm.</p> </li> <li> <code>top_pos</code>               (<code>tuple[float, float]</code>)           \u2013            <p>Position of the top marker in mm.</p> </li> </ul>"},{"location":"modules/#pupil_labs.ir_plane_tracker.TrackerParams.bottom_pos","title":"bottom_pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bottom_pos: tuple[float, float] = (nan, nan)\n</code></pre> <p>Position of the bottom marker in mm.</p>"},{"location":"modules/#pupil_labs.ir_plane_tracker.TrackerParams.left_pos","title":"left_pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>left_pos: tuple[float, float] = (nan, nan)\n</code></pre> <p>Position of the left marker in mm.</p>"},{"location":"modules/#pupil_labs.ir_plane_tracker.TrackerParams.plane_height","title":"plane_height  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>plane_height: float = nan\n</code></pre> <p>Height of the tracked plane in mm.</p>"},{"location":"modules/#pupil_labs.ir_plane_tracker.TrackerParams.plane_width","title":"plane_width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>plane_width: float = nan\n</code></pre> <p>Width of the tracked plane in mm.</p>"},{"location":"modules/#pupil_labs.ir_plane_tracker.TrackerParams.right_pos","title":"right_pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>right_pos: tuple[float, float] = (nan, nan)\n</code></pre> <p>Position of the right marker in mm.</p>"},{"location":"modules/#pupil_labs.ir_plane_tracker.TrackerParams.top_pos","title":"top_pos  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>top_pos: tuple[float, float] = (nan, nan)\n</code></pre> <p>Position of the top marker in mm.</p>"},{"location":"coverage/","title":"Coverage","text":""}]}